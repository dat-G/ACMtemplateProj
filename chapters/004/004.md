# 4. æ•°æ®ç»“æ„

## 4.1 æ ˆ

> Description:\
> ä¸€ç§å…ˆè¿›åå‡ºçš„æ•°æ®ç»“æ„
> å®ç°ç®€å•ï¼Œçœç•¥

STLï¼š

```cpp
stack<int> s;
s.push(1);
s.pop();
s.top();
```

## 4.2. é˜Ÿåˆ—

> Description:\
> ä¸€ç§å…ˆè¿›å…ˆå‡ºçš„æ•°æ®ç»“æ„
> å®ç°ç®€å•ï¼Œçœç•¥
STLï¼š

```cpp
queue<int> q;
q.push(1);
q.pop();
q.front();
q.back();
```

### 4.2.1 ä¼˜å…ˆé˜Ÿåˆ—

> Description:\
> å †æ’åºï¼Œä½¿ç”¨äºŒå‰å †å®ç°
> æ’å…¥æœ€åæ—¶é—´å¤æ‚åº¦ï¼šO(logN)
STL:

```cpp
priority_queue<int> pq;
pq.push(1);
pq.pop();
pq.top();
```

### 4.2.2 å•è°ƒé˜Ÿåˆ—

> Description:\
> é€šè¿‡åˆ é™¤ä¸æ’å…¥çš„æ“ä½œï¼Œä½¿é˜Ÿåˆ—æ»¡è¶³å•è°ƒæ€§\
> å¯¹éƒ¨åˆ†dpå¯ç”¨æ¥ä¼˜åŒ–æ—¶é—´

## 4.3. é“¾è¡¨

> Description:\
> O(n)çš„æ’å…¥ã€åˆ é™¤ã€æŸ¥æ‰¾\
> å¯ä»¥ç”¨é™æ€é“¾è¡¨ä¼˜åŒ–å¢åˆ æ”¹æŸ¥
> å¯ä»¥ä½¿ç”¨STLä¸­çš„listå®ç°\
> å…·ä½“æ–¹æ³•æœªçŸ¥\

```cpp
struct ListNode {
    int l_pointer;
    int r_pointer;
};
ListNode list[N];
//value ä¸ºæ•°ç»„ä¸‹æ ‡
```

## 4.4. å †

### 4.4.1 æ ‘å †

> Description:\
> å…·æœ‰å †å’Œæ ‘çš„æ€§è´¨ä¸€ç§æ•°æ®ç»“æ„

### 4.4.2 äºŒå‰å †

> Description:\
>
## 4.5. æ ‘

> Description:\
> æ ‘å°±æ˜¯æ— ç¯å›¾

### 4.5.1. äºŒå‰æ ‘

> Description:\
> ä»»ä½•èŠ‚ç‚¹æœ€å¤šæœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹çš„æ ‘\
> å­èŠ‚ç‚¹åŒºåˆ†å·¦å³\
> å…¶ä¸­å®Œå…¨äºŒå‰æ ‘ä¸ºä»»ä½•èŠ‚ç‚¹æœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹ï¼Œæˆ–è€…æ²¡æœ‰å­èŠ‚ç‚¹çš„æ ‘\

### 4.5.2. äºŒå‰æœç´¢æ ‘

> Description:\
> äºŒå‰æ ‘ï¼Œæ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼š
>
> 1. æ¯ä¸ªèŠ‚ç‚¹çš„å€¼éƒ½å¤§äºç­‰äºå…¶å·¦å­æ ‘çš„æ‰€æœ‰èŠ‚ç‚¹çš„å€¼
> 2. æ¯ä¸ªèŠ‚ç‚¹çš„å€¼éƒ½å°äºç­‰äºå…¶å³å­æ ‘çš„æ‰€æœ‰èŠ‚ç‚¹çš„å€¼
> 3. æ²¡æœ‰èŠ‚ç‚¹çš„å€¼ç›¸ç­‰
>
> äºŒå‰æœç´¢æ ‘å¯ä»¥ä½¿ç”¨å¹³è¡¡æ ‘ç»´æŠ¤æ ‘é«˜ä»¥ä¸ºä¿è¯å¢åˆ æ”¹æŸ¥çš„å¤æ‚åº¦ä¸ºO(logN)

### 4.5.3. LCA

> Description:\
> æ±‚ä¸¤ä¸ªèŠ‚ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ
> å¯ç”¨äºæ ‘ä¸Šæœ€çŸ­è·¯å¾„é—®é¢˜å’Œ

#### 4.5.3.1. å€å¢è¡¨

#### 4.5.3.2. Tarjanç¦»çº¿ç®—æ³•

### 4.5.4 æ ‘é“¾å‰–åˆ†

### 4.5.5 LCT

## 4.6. çº¿æ®µæ ‘

> Description:\
> ä½¿ç”¨åˆ†æ²»æ€æƒ³çš„æ•°æ®ç»“æ„\
> å¯å®ç°å•ç‚¹ä¿®æ”¹ï¼Œå•ç‚¹æŸ¥è¯¢ï¼ŒåŒºé—´æŸ¥è¯¢ï¼ŒåŒºé—´ä¿®æ”¹\
> çµæ´»çš„å®ç°äº†çº¿æ®µæ ‘çš„æŸ¥è¯¢ï¼Œä¿®æ”¹ï¼Œæ±‚å’Œï¼Œæ±‚æœ€å¤§å€¼ï¼Œæ±‚æœ€å°å€¼ï¼Œæ±‚å’Œçš„åŒºé—´å’Œ\
> æ€»ä¹‹å°±æ˜¯å¾ˆæœ‰ç”¨\
> æ•°æ®ç»“æ„é‡ä¸­ä¹‹é‡ï¼Œå¾—çº¿æ®µæ ‘è€…å¾—å¤©ä¸‹\
> ç»™ğŸ‘´å­¦

### 4.6.1 åŒºé—´çº¿æ®µæ ‘

> Description:\
> å¯¹åŒºé—´å»ºæ ‘

```cpp

struct segmentTree
{
    #define ls (2*idx)
    #define rs (2*idx+1)
    #define mid ((l+r)>>1)
    #define N 100000
    int node[N*4];
    int lazy[N*4];
    int n;
    void build(int idx,int l,int r)
    {
        if(l==r)
        {
            node[idx]=1;
            return;
        }
        build(ls,l,mid);
        build(rs,mid+1,r);
        node[idx]=node[ls]+node[rs];
    }
    void pushDown(int idx,int l,int r)
    {
        if(lazy[idx]!=0)
        {
            node[idx]=lazy[idx]*(r-l+1);
            if(l!=r)
            {
                lazy[ls]=lazy[idx];
                lazy[rs]=lazy[idx];
            }
            lazy[idx]=0;
        }
    }
    //åŒºé—´ä¿®æ”¹
    void update(int idx,int l,int r,int ql,int qr,int val)
    {
        if(ql<=l&&r<=qr)
        {
            node[idx]=val*(r-l+1);
            if(l!=r)
            {
                lazy[ls]=val;
                lazy[rs]=val;
            }
            return;
        }
        pushDown(idx,l,r);
        int mid=mid;
        if(ql<=mid)
        {
            update(ls,l,mid,ql,qr,val);
        }
        if(qr>mid)
        {
            update(rs,mid+1,r,ql,qr,val);
        }
        node[idx]=node[ls]+node[rs];
    }
    //æ±‚åŒºé—´å’Œ
    int query(int idx,int l,int r,int ql,int qr)
    {
        if(ql<=l&&r<=qr)
        {
            return node[idx];
        }
        pushDown(idx,l,r);
        int mid=mid;
        int ans=0;
        if(ql<=mid)
        {
            ans+=query(ls,l,mid,ql,qr);
        }
        if(qr>mid)
        {
            ans+=query(rs,mid+1,r,ql,qr);
        }
        return ans;
    }
};
```

### 4.6.2 æƒå€¼çº¿æ®µæ ‘

> Description:\
> ç»´æŠ¤è‹¥å¹²ä¸ªæ¡¶\
> å¯¹å€¼åŸŸå»ºæ ‘ï¼Œç”±äºå€¼åŸŸçš„å¤§å°ä¸ç¡®å®šï¼Œæ‰€ä»¥éœ€è¦åŠ¨æ€åˆ†é…ç©ºé—´

```cpp
struct segmentTree
{
    //åŠ¨æ€å¼€ç‚¹æƒå€¼çº¿æ®µæ ‘
    #define mid ((l+r)>>1)
    #define N 100000
    int ls[N*4];
    int rs[N*4];

    int node[N*4];
    int lazy[N*4];
    int n;
    int cnt=0;
    void build(int idx,int l,int r)
    {
        if(!idx)
        {
            idx=++cnt;
        }
        if(l==r)
        {
            node[idx]=1;
            return;
        }
        build(ls[idx],l,mid);
        build(rs[idx],mid+1,r);
        node[idx]=node[ls[idx]]+node[rs[idx]];
    }
    void pushDown(int idx,int l,int r)
    {
        if(lazy[idx]!=0)
        {
            node[idx]=lazy[idx]*(r-l+1);
            if(l!=r)
            {
                lazy[ls[idx]]=lazy[idx];
                lazy[rs[idx]]=lazy[idx];
            }
            lazy[idx]=0;
        }
    }
    //æ‰¾kæ˜¯ç¬¬å‡ ä¸ªæ•°
    int find(int idx,int l,int r,int k)
    {
        if(l==r)
        {
            return l;
        }
        pushDown(idx,l,r);
        int mid=mid;
        if(node[ls[idx]]<k)
        {
            return find(rs[idx],mid+1,r,k-node[ls[idx]]);
        }
        else
        {
            return find(ls[idx],l,mid,k);
        }
    }
}
```

### 4.6.3 æ ‘å¥—æ ‘

> Description:\
> ä»¥çº¿æ®µæ ‘å¥—setä¸ºä¾‹\
> çº¿æ®µæ ‘çš„èŠ‚ç‚¹å˜ä¸ºä¸€ä¸ªå¹³è¡¡æ ‘å¹³è¡¡æ ‘ä¸­ä¿å­˜ç€è¿™ä¸ªçº¿æ®µæ ‘çš„å­èŠ‚ç‚¹çš„ä¿¡æ¯ï¼Œè¿™æ ·å¯ä»¥å®ç°åŒºé—´å€¼åŸŸ

```cpp
#define N 100000
aa[N];
struct segSet{
    #define mid ((l+r)>>1)
    #define ls (2*idx)
    #define rs (2*idx+1)
    set<int> node[N*4];
    void build(int idx,int l,int r)
    {
        if(l==r)
        {
            node[idx].insert(aa[l]);
            return;
        }
        build(ls,l,mid);
        build(rs,mid+1,r);
        node[idx].insert(node[ls].begin(),node[ls].end());
        node[idx].insert(node[rs].begin(),node[rs].end());

    }
    //ql,qræ˜¯è¦æŸ¥è¯¢çš„åŒºé—´
    //è¿”å›åŒºé—´æœ€å¤§å€¼
    int queryMax(int idx,int l,int r,int ql,int qr)
    {
        if(ql<=l&&r<=qr)
        {
            return *node[idx].rbegin();
        }
        pushDown(idx,l,r);
        int mid=mid;
        if(qr<l||r<ql)
        {
            return -1;
        }
        else
        {
            return max(queryMax(ls,l,mid,ql,qr),queryMax(rs,mid+1,r,ql,qr));

        }

        //åŒç†å¯å¾—æŸ¥è¯¢åŒºé—´æœ€å°å€¼
        //åŒç†å¯ä»¥æŸ¥è¯¢æŸä¸€å€¼åœ¨åŒºé—´çš„æœ€å·¦å’Œæœ€å³ä½ç½®
    }
}
```

### 4.6.4 å¯æŒä¹…åŒ–çº¿æ®µæ ‘

> Description:\
> ä½¿ç”¨åŠ¨æ€å¼€ç‚¹ä¿å­˜æ–°æ•°æ®ï¼Œæ¯æ¬¡æ›´æ–°éƒ½æ–°å»ºä¸€ä¸ªæ ¹èŠ‚ç‚¹\

```cpp
//wait for complete
```

## 4.7. å¹³è¡¡æ ‘

> Description:\
> æ ‘é“¾æœ€é•¿å’Œæœ€çŸ­ä¹‹é—´çš„å·®å°äºç­‰äºæœ€çŸ­æ ‘é“¾é•¿åº¦\
> å¸¸ç”¨äºäºŒå‰æœç´¢æ ‘ä¼˜åŒ–

### 4.7.1 splay

> Description:\
> ä¼¸å±•æ ‘

```cpp
struct splay
{
    struct node
    {
        int val;
        node* left;
        node* right;
        node* parent;
        node(int v):val(v),left(nullptr),right(nullptr),parent(nullptr){}
        ~node()
        {
            if(left)delete left;
            if(right)delete right;
        }
    };
    node* root;
    int size;
    splay()
    {
        root=nullptr;
        size=0;
    }
    ~splay()
    {
        if(root)delete root;
    }
    void rotate(node* x)
    {
        node* y=x->parent;
        node* z=y->parent;
        if(!z)
        {
            root=x;
            x->parent=nullptr;
        }
        else
        {
            (z->left==y)?z->left=x:z->right=x;
            x->parent=z;
        }
        if(y->left==x)
        {
            y->left=y->right;
            if(y->left)
            {
                y->left->parent=y;
            }
            y->right=x;
            x->parent=y;
        }
        else
        {
            y->right=y->left;
            if(y->right)
            {
                y->right->parent=y;
            }
            y->left=x;
            x->parent=y;
        }
    }
    void splay(node* x)
    {

        while(x->parent)
        {
            if(!x->parent->parent)
            {
                rotate(x);
            }
            else
            {
                if(x->parent->left==x&&x->parent->parent->left==x->parent)
                {
                    rotate(x->parent);
                    rotate(x);
                }
                else if(x->parent->right==x&&x->parent->parent->right==x->parent)
                {
                    rotate(x->parent);
                    rotate(x);
                }
                else
                {
                    rotate(x);
                    rotate(x);
                }
            }
        }
    }
    void insert(int v)
    {

        node* x=root;
        node* y=nullptr;

        while(x)
        {
            y=x;
            (v<x->val)?x=x->left:x=x->right;
        }
        node* z=new node(v);
        if(!y)
        {
            root=z;
        }
        else
        {
            (y->val<v)?y->right=z:y->left=z;
            z->parent=y;
        }
        splay(z);
        size++;
    }
    node* find(int v)
    {
        node* x=root;
        while(x)
        {
            if(x->val==v)
            {
                return x;
            }
            (x->val<v)?x=x->right:x=x->left;
        }
        return nullptr;
    }
    void erase(int v)
    {
        node* x=find(v);
        if(!x)return;
        if(!x->left)
        {
            if(!x->right)
            {
                if(x==root)
                {
                    root=nullptr;
                }
                else
                {
                    (x->parent->left==x)?x->parent->left=nullptr:x->parent->right=nullptr;
                }
            }
            else
            {
                if(x==root)
                {
                    root=x->right;
                    root->parent=nullptr;
                }
                else
                {
                    if(x->parent->left==x)
                    {
                        x->parent->left=x->right;
                        x->right->parent=x->parent;
                    }
                    else
                    {
                        x->parent->right=x->right;
                        x->right->parent=x->parent;
                    }
                }
            }
        }
        else
        {
            node* y=x->left;
            while(y->right)
            {
                y=y->right;
            }
            splay(y);
            if(x==root)
            {
                root=y;
                y->right=x->right;
                if(y->right)
                {
                    y->right->parent=y;
                }
            }
            else
            {
                (x->parent->left==x)?x->parent->left=y:x->parent->right=y;
                y->right=x->right;
                if(y->right)
                {
                    y->right->parent=y;
                }
            }
        }
        delete x;
        size--;
    }
    int find_kth(int k)
    {
        //æ‰¾åˆ°ç¬¬kå°çš„å…ƒç´ 
        node* x=root;
        while(x)
        {
            int r=rank(x->val);
            if(r==k)
            {
                return x->val;
            }
            (r<k)?x=x->right:x=x->left;
        }
        return -1;
    }
};


    
```

## 4.8. æ ‘çŠ¶æ•°ç»„

> Description:\
> é€‚åˆå¤„ç†ç±»ä¼¼äºå‰ç¼€å’Œçš„é—®é¢˜

```cpp
int data[N];
struct treeArray
{
    #define lowbit(x) (x&(-x))
    #define N 100000
    int leaf[N];
    int get(int idx)
    {
        int sum=0;
        while(idx>0)
        {
            sum+=leaf[idx];
            idx-=lowbit(idx);
        }
        return sum;
    }
    void update(int idx,int x)
    {
        while(idx<=N)
        {
            leaf[idx]+=x;
            idx+=lowbit(idx);
        }
    }
}
```
