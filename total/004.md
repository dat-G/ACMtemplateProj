# 4. æ•°æ®ç»“æ„

## 4.1 æ ˆ

> Description:\
> ä¸€ç§å…ˆè¿›åå‡ºçš„æ•°æ®ç»“æ„
> å®ç°ç®€å•ï¼Œçœç•¥

STLï¼š

```cpp
stack<int> s;
s.push(1);
s.pop();
s.top();
```

## 4.2. é˜Ÿåˆ—

> Description:\
> ä¸€ç§å…ˆè¿›å…ˆå‡ºçš„æ•°æ®ç»“æ„
> å®ç°ç®€å•ï¼Œçœç•¥
STLï¼š

```cpp
queue<int> q;
q.push(1);
q.pop();
q.front();
q.back();
```

### 4.2.1 ä¼˜å…ˆé˜Ÿåˆ—

> Description:\
> å †æ’åºï¼Œä½¿ç”¨äºŒå‰å †å®ç°
> æ’å…¥æœ€åæ—¶é—´å¤æ‚åº¦ï¼šO(logN)
STL:

```cpp
priority_queue<int> pq;
pq.push(1);
pq.pop();
pq.top();
```

### 4.2.2 å•è°ƒé˜Ÿåˆ—

> Description:\
> é€šè¿‡åˆ é™¤ä¸æ’å…¥çš„æ“ä½œï¼Œä½¿é˜Ÿåˆ—æ»¡è¶³å•è°ƒæ€§\
> å¯¹éƒ¨åˆ†dpå¯ç”¨æ¥ä¼˜åŒ–æ—¶é—´

## 4.3. é“¾è¡¨

> Description:\
> O(n)çš„æ’å…¥ã€åˆ é™¤ã€æŸ¥æ‰¾\
> å¯ä»¥ç”¨é™æ€é“¾è¡¨ä¼˜åŒ–å¢åˆ æ”¹æŸ¥
> å¯ä»¥ä½¿ç”¨STLä¸­çš„listå®ç°\
> å…·ä½“æ–¹æ³•æœªçŸ¥\

```cpp
struct ListNode {
    int l_pointer;
    int r_pointer;
};
ListNode list[N];
//value ä¸ºæ•°ç»„ä¸‹æ ‡
```

## 4.4. å †

### 4.4.1 æ ‘å †

> Description:\
> å…·æœ‰å †å’Œæ ‘çš„æ€§è´¨ä¸€ç§æ•°æ®ç»“æ„

### 4.4.2 äºŒå‰å †

> Description:\
>
## 4.5. æ ‘

> Description:\
> æ ‘å°±æ˜¯æ— ç¯å›¾

### 4.5.1. äºŒå‰æ ‘

> Description:\
> ä»»ä½•èŠ‚ç‚¹æœ€å¤šæœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹çš„æ ‘\
> å­èŠ‚ç‚¹åŒºåˆ†å·¦å³\
> å…¶ä¸­å®Œå…¨äºŒå‰æ ‘ä¸ºä»»ä½•èŠ‚ç‚¹æœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹ï¼Œæˆ–è€…æ²¡æœ‰å­èŠ‚ç‚¹çš„æ ‘\

### 4.5.2. äºŒå‰æœç´¢æ ‘

> Description:\
> äºŒå‰æ ‘ï¼Œæ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼š
>
> 1. æ¯ä¸ªèŠ‚ç‚¹çš„å€¼éƒ½å¤§äºç­‰äºå…¶å·¦å­æ ‘çš„æ‰€æœ‰èŠ‚ç‚¹çš„å€¼
> 2. æ¯ä¸ªèŠ‚ç‚¹çš„å€¼éƒ½å°äºç­‰äºå…¶å³å­æ ‘çš„æ‰€æœ‰èŠ‚ç‚¹çš„å€¼
> 3. æ²¡æœ‰èŠ‚ç‚¹çš„å€¼ç›¸ç­‰
>
> äºŒå‰æœç´¢æ ‘å¯ä»¥ä½¿ç”¨å¹³è¡¡æ ‘ç»´æŠ¤æ ‘é«˜ä»¥ä¸ºä¿è¯å¢åˆ æ”¹æŸ¥çš„å¤æ‚åº¦ä¸ºO(logN)

### 4.5.3. LCA

> Description:\
> æ±‚ä¸¤ä¸ªèŠ‚ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ
> å¯ç”¨äºæ ‘ä¸Šæœ€çŸ­è·¯å¾„é—®é¢˜å’Œ

#### 4.5.3.1. å€å¢è¡¨

> Description:\
> åŸºæœ¬æ€æƒ³å’Œstè¡¨ç›¸åŒï¼Œç”¨ä¸€ä¸ªæ•°ç»„è®°å½•æ¯ä¸ªèŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹
> ç„¶åæ±‚è§£çˆ¶èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ï¼Œä¸å­˜åœ¨çˆ¶èŠ‚ç‚¹ï¼Œå’Œè·¯å¾„å‹ç¼©ç±»ä¼¼
> è¯¢é—®æ—¶ä»ä¸Šåˆ°ä¸‹ï¼Œå¤æ‚åº¦$O(logn)$
> æ±‚è§£lcaé—®é¢˜æ—¶ï¼Œå…ˆè®²ä¸¤ä¸ªèŠ‚ç‚¹è·³è½¬åˆ°åŒä¸€æ·±åº¦ï¼Œç„¶åè®°å½•æœ€åä¸€ä¸ªæ˜¯å…¬å…±çš„ç¥–å…ˆèŠ‚ç‚¹çš„èŠ‚ç‚¹
> å¤æ‚åº¦$O(logn)$
> é¢„å¤„ç†æ—¶é—´$O(n)$

```cpp
#define NN 1145140

using namespace std;

int fa[NN][32];

int n;


int depth[NN];  
int depth_val[NN];

unordered_map<int,unordered_map<int,int>>mp;
unordered_map<int,bool>check_dfs;
void dfs(int deep,int i)//æ·±æœå¤„ç†ç¬¬ä¸€ä¸ªå±‚çˆ¶èŠ‚ç‚¹å’Œæ·±åº¦ä¿¡æ¯
{
    depth[i]=deep;
    check_dfs[i]=true;
    if(mp[i].size()==0)return;
    for(auto x:mp[i])
    {

        if(check_dfs[x.first])continue;
        fa[x.first][0]=i;
        depth_val[x.first]=depth_val[i]+x.second;
        dfs(deep+1,x.first);
    }
    return;
}
void LCA_initial(int n)//åˆå§‹åŒ–faæ•°ç»„ï¼Œ
{
    int max_deep=int(log(n)/log(2));
    for(int j=1;j<=max_deep;j++)
    {
        for(int i=0;i<n;i++)
        {
            if(fa[i][j-1]!=-1)fa[i][j]=fa[fa[i][j-1]][j-1];
        }
    }
    return;
}

int LCA_query(int x,int y)
{
    if(depth[x]<depth[y])//å¤„ç†æ·±åº¦ä¸åŒ
    {
        x^=y;
        y^=x;
        x^=y;
    }
    int cc;
    int logs=(int)(log(depth[x])/log(2));
    for(int i=logs;i>=0;i--)
    {
        if(depth[x]-(1<<i)>=depth[y])//è·³åˆ°åŒæ ·çš„æ·±åº¦
        {
            x=fa[x][i];
        }
    }
    if(x==y)return x;
    for(int i=logs;i>=0;i--)//è¯¢é—®ï¼Œå¦‚æœfa[v][i]ä¸åŒå°±å‘ä¸Šè·³ï¼Œ
    //æœ€åçš„fa[x][0]å°±æ˜¯ç­”æ¡ˆ
    {
        if(fa[x][i]!=-1&&fa[x][i]!=fa[y][i]&&fa[y][i]!=-1)
        {
            x=fa[x][i];
            y=fa[y][i];
        }
    }
    return fa[x][0];
}

int get_dis(int u,int v)//æ ‘ä¸Šæœ€çŸ­è·¯
{
    if(u==v)return 0;
    else
    {
        return depth_val[u]+depth_val[v]-2*depth_val[LCA_query(u,v)];
    }
}
```

#### 4.5.3.2. Tarjanç¦»çº¿ç®—æ³•

> Description:\
> å’Œå€å¢è¡¨ä¸åŒï¼Œå€å¢è¡¨çš„æŸ¥è¯¢æ—¶åœ¨çº¿çš„ï¼ŒTarjanç¦»çº¿ç®—æ³•çš„æŸ¥è¯¢ç¦»çº¿çš„
> æ ¸å¿ƒæ€æƒ³æ˜¯æ ‘çš„dfsåºçš„å…³ç³»ï¼Œéœ€è¦ä½¿ç”¨å¹¶æŸ¥é›†
> æ¯å½“éå†å®Œä¸€ä¸ªèŠ‚ç‚¹ï¼Œå°±å°†è¯¥èŠ‚ç‚¹ä¸çˆ¶èŠ‚ç‚¹åˆå¹¶ï¼Œæ¯æ¬¡éå†æ£€ç´¢æ˜¯å¦è¦æ±‚è§£å’Œè¯¥èŠ‚ç‚¹ç›¸å…³çš„lcaé—®é¢˜
> å¦‚æœå¦ä¸€èŠ‚ç‚¹å·²ç»è®¿é—®è¿‡ï¼Œç­”æ¡ˆå°±æ˜¯é‚£ä¸ªèŠ‚ç‚¹å¹¶æŸ¥é›†æ‰€æŒ‡å‘çš„èŠ‚ç‚¹

### 4.5.4 æ ‘é“¾å‰–åˆ†

> Description:\
> è®²æ ‘åˆ†ä¸ºè½»è¾¹å’Œé‡è¾¹ä¸¤éƒ¨åˆ†
> åˆ†æˆå¤šä¸ªç”±è½»è¾¹ç›¸è¿çš„é‡é“¾ï¼Œå¯ä»¥å°†æ ‘ä¸Šé—®é¢˜ç”¨çº¿æ®µæ ‘è§£å†³ï¼Œ
> æ¯”å¦‚é“¾ä¸ŠåŒºé—´ä¿®æ”¹å’Œè¯¢é—®
> ä»¥ä¸‹ä»£ç æ„Ÿè°¢ @Jadebo1 æä¾›ï¼ˆæœ‰åˆ æ”¹ï¼‰
> [æºç é“¾æ¥](https://www.luogu.com.cn/blog/Jadebo1/shu-lian-pou-fen-ru-men)

```cpp
map<int,map<int,int>>mp;//è¾¹æƒå›¾
int deep[NN];//èŠ‚ç‚¹æ·±åº¦æ ‡è®°
int father[NN];//èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹
int son_tree_size[NN];//å­æ ‘å¤§å°
int heavy_son[NN];//è¯¥èŠ‚ç‚¹çš„é‡å­èŠ‚ç‚¹ç¼–å·
int dfs_id[NN];//è¯¥èŠ‚ç‚¹çš„dfsåº
int top_node_id[NN];//æ‰€å¤„æ ‘é“¾çš„é¡¶èŠ‚ç‚¹ç¼–å·
segment_tree<int>seg;//çº¿æ®µæ ‘
void dfs1(int now_node, int father_node)//æ·±åº¦ï¼Œé‡å„¿å­ï¼Œçˆ¶èŠ‚ç‚¹é¢„å¤„ç†
{
    deep[now_node] = deep[father_node] + 1;//å­èŠ‚ç‚¹æ·±åº¦ä¸ºçˆ¶èŠ‚ç‚¹æ·±åº¦+1
    father[now_node] = father_node;
    son_tree_size[now_node] = 1;//å­æ ‘åŒ…å«è‡ªå·±
    int max_size = -1;
    for (auto next_node : mp[now_node])
    {
        if (next_node.first == father_node)
            continue;
        dfs1(next_node.first, now_node);
        son_tree_size[now_node] += son_tree_size[next_node.first];
        if (son_tree_size[next_node.first] > max_size)//è·å–å½“å‰èŠ‚ç‚¹é‡å„¿å­çš„ç¼–å·
        {
            max_size = son_tree_size[next_node.first];
            heavy_son[now_node] = next_node.first;
        }
    }
}
void dfs2(int now_node,int top_node)
{
    dfs_id[now_node]=++tot;//æŒ‰ç…§dfsåºç»™å„èŠ‚ç‚¹é‡æ–°èµ‹å€¼
    top_node_id[now_node]=top_node;
    if(!heavy_son[now_node])
    return;
    dfs2(heavy_son[now_node],top_node);//é‡å„¿å­çš„é“¾å¤´ä¾ç„¶ä¸ºå…¶çˆ¶èŠ‚ç‚¹çš„é“¾å¤´ï¼ˆé‡é“¾ï¼‰
    for(auto x :mp[now_node])
    {
        if(x.first==father[now_node]||x.first==heavy_son[now_node])
        continue;
        dfs2(x.first,x.first);//è½»å„¿å­çš„é“¾å¤´ä¸ºè‡ªå·±ï¼ˆè½»é“¾ï¼‰
    }
}
void modify(int x,int y,long long k)
{
    while(top_node_id[x]!=top_node_id[y])//è‹¥ä¸¤èŠ‚ç‚¹ä¸å†åŒä¸€æ¡æ ‘é“¾ä¸Š
    {
        if(deep[top_node_id[x]]<deep[top_node_id[y]])
        swap(x,y);
        seg.add(1,1,n,id[top_node_id[x]],dfs_id[x],k);//å…ˆå¤„ç†é“¾å¤´è¾ƒæ·±çš„ä¸€éƒ¨åˆ†
        x=father[top_node_id[x]];//çˆ¬å‡è‡³é“¾å¤´
    }
    if(deep[x]>deep[y])
    swap(x,y);
    seg.add(1,1,n,dfs_id[x],dfs_id[y],k);//å¤„ç†åŒä¸€æ¡æ ‘é“¾ä¸Šçš„åŒºé—´
}
long long qRange(int x,int y)
{
    long long res=0;
    while(top_node_id[x]!=top_node_id[y])
    {
        if(deep[top_node_id[x]]<deep[top_node_id[y]])
        swap(x,y);
        res+=seg.query(1,1,n,dfs_id[top_node_id[x]],dfs_id[x]);
        x=father[top_node_id[x]];
    }
    if(deep[x]>deep[y])
    swap(x,y);
    res+=seg.query(1,1,n,dfs_id[x],dfs_id[y]);
    return res;
}
```

### 4.5.5 LCT

> Description:\
> Link Cut Tree
> æ ‘é“¾å‰–åˆ†çš„é‡é“¾ä¸è½»é“¾æ˜¯é¢„å¤„ç†çš„ï¼Œä¸èƒ½åšå¸¦ä¿®é—®é¢˜
> LCTå¯ä»¥è§£å†³è¿™ä¸ªé—®é¢˜
> LCTåªæœ‰ä¸¤ä¸ªæ“ä½œï¼ŒAccess å’Œ Splay
> ç”¨ Splay Tree ç»´æŠ¤é‡é“¾ä¿¡æ¯ï¼Œ
> LCTéš¾åº¦è¿‡é«˜ï¼Œæ²¡å¿…è¦å†™åœ¨è¿™é‡Œ ~~å…¶å®æ˜¯æˆ‘ä¸ä¼šå†™~~

## 4.6. çº¿æ®µæ ‘

> Description:
> ä½¿ç”¨åˆ†æ²»æ€æƒ³çš„æ•°æ®ç»“æ„
> å¯å®ç°å•ç‚¹ä¿®æ”¹ï¼Œå•ç‚¹æŸ¥è¯¢ï¼ŒåŒºé—´æŸ¥è¯¢ï¼ŒåŒºé—´ä¿®æ”¹\
> çµæ´»çš„å®ç°äº†çº¿æ®µæ ‘çš„æŸ¥è¯¢ï¼Œä¿®æ”¹ï¼Œæ±‚å’Œï¼Œæ±‚æœ€å¤§å€¼ï¼Œæ±‚æœ€å°å€¼ï¼Œæ±‚å’Œçš„åŒºé—´å’Œ
> æ€»ä¹‹å°±æ˜¯å¾ˆæœ‰ç”¨
> æ•°æ®ç»“æ„é‡ä¸­ä¹‹é‡ï¼Œå¾—çº¿æ®µæ ‘è€…å¾—å¤©ä¸‹\
> ç»™**ğŸ‘´**å­¦

### 4.6.1 åŒºé—´çº¿æ®µæ ‘

> Description:\
> å¯¹åŒºé—´å»ºæ ‘

```cpp

struct segmentTree
{
    #define ls (idx<<1)
    #define rs (ls|1)
    #define mid ((l+r)>>1)
    #define N 100000
    int node[N*4];
    int lazy[N*4];
    int n;
    void build(int idx,int l,int r)
    {
        if(l==r)
        {
            node[idx]=1;
            return;
        }
        build(ls,l,mid);
        build(rs,mid+1,r);
        node[idx]=node[ls]+node[rs];
        lazy[idx]=0;
    }
    void pushDown(int idx,int l,int r)
    {
        if(lazy[idx]!=0)
        {
            node[ls]+=lazy[idx]*(mid-l+1);
            node[rs]+=lazy[idx]*(r-mid);
            if(l!=r)
            {
                lazy[ls]=lazy[idx];
                lazy[rs]=lazy[idx];
            }
            lazy[idx]=0;
        }
    }
    void add_range(int idx,int l,int r,int L,int R,int k)
    {
        if(r<L||l>R)
            return;
        else if(l>=L&&r<=R)
        {
            node[idx]+=k*(r-l+1);
            if(l!=r)
            {
                lazy[ls]+=k;
                lazy[rs]+=k;
            }
        }
        else
        {
            pushDown(idx,l,r);
            add_range(ls,l,mid,L,R,k);
            add_range(rs,mid+1,r,L,R,k);
            node[idx]=node[ls]+node[rs];
        }
    }
    int sum_range(int idx,int l,int r,int L,int R)
    {
        if(r<L||l>R)
            return 0;
        else if(l>=L&&r<=R)
        {
            return node[idx];
        }
        else
        {
            pushDown(idx,l,r);
            return sum_range(ls,l,mid,L,R,ans) + sum_range(rs,mid+1,r,L,R,ans);
            node[idx]=node[ls]+node[rs];
        }
    }
};
```

### 4.6.2 æƒå€¼çº¿æ®µæ ‘

> Description:\
> ç»´æŠ¤è‹¥å¹²ä¸ªæ¡¶\
> å¯¹å€¼åŸŸå»ºæ ‘ï¼Œç”±äºå€¼åŸŸçš„å¤§å°ä¸ç¡®å®šï¼Œæ‰€ä»¥éœ€è¦åŠ¨æ€åˆ†é…ç©ºé—´

```cpp
struct segmentTree
{
    //åŠ¨æ€å¼€ç‚¹æƒå€¼çº¿æ®µæ ‘
    #define mid ((l+r)>>1)
    #define N 1005000
    int ls[N*4];
    int rs[N*4];

    int node[N*4];
    int lazy[N*4];
    int n;
    int cnt=0;
    void push_down(int x,int l,int r)
    {
        if(lazy[x]!=0&&l!=r)
        {
            node[x]+=lazy[x]*(r-l+1);
            if(ls[x]==0)ls[x]=++cnt;
            if(rs[x]==0)rs[x]=++cnt;
            lazy[ls[x]]+=lazy[x];
            lazy[rs[x]]+=lazy[x];
            lazy[x]=0;
        }
    }
    void add_point(int &idx,int l,int r,int val)
    {
        if(!idx)idx=++cnt;
        if(l==r)
        {
            if(l==val)node[idx]++;
            return;
        }
        push_down(idx,l,r);
        if(!ls[idx])ls[idx]=++cnt;
        if(!rs[idx])rs[idx]=++cnt;
        if(val<=mid)add_point(ls[idx],l,mid,val);
        else add_point(rs[idx],mid+1,r,val);
        node[idx]=node[ls[idx]]+node[rs[idx]];
    }
    int kth(int idx,int l,int r,int k)
    {
        if(l==r)
        {
            return l;
        }
        push_down(idx,l,r);
        if(k<=node[ls[idx]])return kth(ls[idx],l,mid,k);
        else return kth(rs[idx],mid+1,r,k-node[ls[idx]]);
    }
    int find_kth(int idx,int l,int r,int k)
    {
        if(l==r)return l==k;
        push_down(idx,l,r);
        if(ls[idx]>=k)return find_kth(ls[idx],l,mid,k);
        else return find_kth(rs[idx],mid+1,r,k-ls[idx])+node[ls[idx]];
    }
};
```

### 4.6.3 æ ‘å¥—æ ‘

> Description:\
> ä»¥çº¿æ®µæ ‘å¥—setä¸ºä¾‹\
> çº¿æ®µæ ‘çš„èŠ‚ç‚¹å˜ä¸ºä¸€ä¸ªå¹³è¡¡æ ‘å¹³è¡¡æ ‘ä¸­ä¿å­˜ç€è¿™ä¸ªçº¿æ®µæ ‘çš„å­èŠ‚ç‚¹çš„ä¿¡æ¯ï¼Œè¿™æ ·å¯ä»¥å®ç°å„ç§å¥‡æ€ªçš„æ“ä½œ
> å®é™…ä¸Šå¯ä»¥å„ç§äº’ç›¸åµŒå¥—


### 4.6.4 å¯æŒä¹…åŒ–çº¿æ®µæ ‘

> Description:
> åˆåä¸»å¸­æ ‘
> ä½¿ç”¨åŠ¨æ€å¼€ç‚¹ä¿å­˜æ–°æ•°æ®ï¼Œæ¯æ¬¡æ›´æ–°éƒ½æ–°å»ºä¸€ä¸ªæ ¹èŠ‚ç‚¹\
> éœ€è¦rootæ•°ç»„ä¿å­˜æ¯ä¸€ä¸ªç‰ˆæœ¬ä½ç½®

```cpp
//wait for complete
```

## 4.7. å¹³è¡¡æ ‘

> Description:\
> æ ‘é“¾æœ€é•¿å’Œæœ€çŸ­ä¹‹é—´çš„å·®å°äºç­‰äºæœ€çŸ­æ ‘é“¾é•¿åº¦\
> å¸¸ç”¨äºäºŒå‰æœç´¢æ ‘ä¼˜åŒ–

### 4.7.1 splay

> Description:\
> ä¼¸å±•æ ‘

```cpp
struct splay_tree
{
    struct node
    {
        int val;
        node* left;
        node* right;
        node* parent;
        node(int v):val(v),left(nullptr),right(nullptr),parent(nullptr){}
        ~node()
        {
            if(left)
                delete left;
            if(right)
                delete right;
        }

    };
    node* root;
    int size;
    splay_tree():root(nullptr),size(0){}
    ~splay_tree()
    {
        if(root)
            delete root;
    }
    void insert(int v)
    {
        if(!root)
        {
            root=new node(v);
            size++;
            return;
        }
        node* cur=root;
        while(cur)
        {
            if(cur->val==v)
            {
                splay(cur);
                return;
            }
            if(cur->val>v)
            {
                if(cur->left)
                    cur=cur->left;
                else
                {
                    cur->left=new node(v);
                    cur->left->parent=cur;
                    size++;
                    splay(cur->left);
                    return;
                }
            }
            else
            {
                if(cur->right)
                    cur=cur->right;
                else
                {
                    cur->right=new node(v);
                    cur->right->parent=cur;
                    size++;
                    splay(cur->right);
                    return;
                }
            }
        }
    }
    void erase(int v)
    {
        if(!root)
            return;
        node* cur=root;
        while(cur)
        {
            if(cur->val==v)
            {
                splay(cur);
                if(cur->left)
                {
                    node* tmp=cur->left;
                    cur->left=nullptr;
                    delete cur;
                    root=tmp;
                    size--;
                    return;
                }
                if(cur->right)
                {
                    node* tmp=cur->right;
                    cur->right=nullptr;
                    delete cur;
                    root=tmp;
                    size--;
                    return;
                }
                delete cur;
                root=nullptr;
                size--;
                return;
            }
            if(cur->val>v)
            {
                if(cur->left)
                    cur=cur->left;
                else
                    return;
            }
            else
            {
                if(cur->right)
                    cur=cur->right;
                else
                    return;
            }
        }
    }
    void splay(node* cur)
    {
        if(!cur)
            return;
        while(cur->parent)
        {
            if(!cur->parent->parent)
            {
                if(cur->parent->left==cur)
                    right_rotate(cur->parent);
                else
                    left_rotate(cur->parent);
            }
            else
            {
                if(cur->parent->left==cur&&cur->parent->parent->left==cur->parent)
                {
                    right_rotate(cur->parent->parent);
                    right_rotate(cur->parent);
                }
                else if(cur->parent->right==cur&&cur->parent->parent->right==cur->parent)
                {
                    left_rotate(cur->parent->parent);
                    left_rotate(cur->parent);
                }
                else if(cur->parent->left==cur&&cur->parent->parent->right==cur->parent)
                {
                    right_rotate(cur->parent);
                    left_rotate(cur->parent);
                }
                else
                {
                    left_rotate(cur->parent);
                    right_rotate(cur->parent);
                }
            }
        }
        root=cur;
    }
    void left_rotate(node* cur)
    {
        if(!cur)
            return;
        node* tmp=cur->right;
        cur->right=tmp->left;
        if(tmp->left)
            tmp->left->parent=cur;
        tmp->parent=cur->parent;
        if(!cur->parent)
            root=tmp;
        else if(cur->parent->left==cur)
            cur->parent->left=tmp;
        else
            cur->parent->right=tmp;
        tmp->left=cur;
        cur->parent=tmp;
    }
    void right_rotate(node* cur)
    {
        if(!cur)
            return;
        node* tmp=cur->left;
        cur->left=tmp->right;
        if(tmp->right)
            tmp->right->parent=cur;
        tmp->parent=cur->parent;
        if(!cur->parent)
            root=tmp;
        else if(cur->parent->left==cur)
            cur->parent->left=tmp;
        else
            cur->parent->right=tmp;
        tmp->right=cur;
        cur->parent=tmp;
    }
    void print()
    {
        if(!root)
            return;
        std::queue<node*> q;
        q.push(root);
        while(!q.empty())
        {
            node* cur=q.front();
            q.pop();
            if(cur->left)
                q.push(cur->left);
            if(cur->right)
                q.push(cur->right);
            std::cout<<cur->val<<" ";
        }
        std::cout<<std::endl;
    }
    node* find(int v)
    {
        if(!root)
            return nullptr;
        node* cur=root;
        while(cur)
        {
            if(cur->val==v)
                return cur;
            if(cur->val>v)
            {
                if(cur->left)
                    cur=cur->left;
                else
                    return nullptr;
            }
            else
            {
                if(cur->right)
                    cur=cur->right;
                else
                    return nullptr;
            }
        }
        return nullptr;
    }
};
```

### 4.7.2. FHQ treap

```cpp

const int N = 2e5 + 3;
mt19937 rnd(233);

int cnt, root;
#define ls fhq[now].l
#define rs fhq[now].r
#define endl "\n"

struct treap
{
    int l, r;
    int val, key;
    int siz;
} fhq[N];
int add(int val) 
{
    fhq[++cnt].val = val;
    fhq[cnt].siz = 1;
    fhq[cnt].key = rnd();
    return cnt;
}
void pushup(int now)
{
    fhq[now].siz = fhq[ls].siz + fhq[rs].siz + 1;
}
void split(int now, int val, int &x, int &y) 
{
    if (!now)
    {
        x = y = 0;
        return;
    }
    else
    {
        if (fhq[now].val <= val) 
        {
            x = now;
            split(fhq[now].r, val, fhq[now].r, y);
        }
        else
        {
            y = now;
            split(fhq[now].l, val, x, fhq[now].l);
        }
        pushup(now);
    }
}
int merge(int x, int y)
{
    if (!x || !y)
        return x + y;

    if (fhq[x].key > fhq[y].key)
    {
        fhq[x].r = merge(fhq[x].r, y);
        pushup(x);
        return x;
    }
    else
    {
        fhq[y].l = merge(x, fhq[y].l);
        pushup(y);
        return y;
    }
}
int x, y, z;
void ins(int val)
{
    split(root, val, x, y);
    root = merge(merge(x, add(val)), y);
}
void del(int val)
{
    split(root, val, x, z);
    split(x, val - 1, x, y);
    y = merge(fhq[y].l, fhq[y].r);
    root = merge(merge(x, y), z);
}
int rk(int val) //æŸ¥è¯¢å€¼çš„æ’å
{
    split(root, val - 1, x, y);
    int temp = fhq[x].siz + 1;
    root = merge(x, y);
    return temp;
}
int num(int rank) 
{
    int now = root;
    while (now)
    {
        if (fhq[ls].siz + 1 == rank)
            break;
        else if (fhq[ls].siz >= rank)
            now = ls;
        else
        {
            rank -= fhq[ls].siz + 1;
            now = rs;
        }
    }
    return fhq[now].val;
}
int pre(int val)
{
    split(root, val - 1, x, y);
    int now = x;
    while (rs)
    {
        now = rs;
    }
    int temp = fhq[now].val;
    root = merge(x, y);
    return temp;
}
int nex(int val)
{
    split(root, val, x, y);
    int now = y;
    while (ls)
    {
        now = ls;
    }
    int temp = fhq[now].val;
    root = merge(x, y);
    return temp;
}

```

### 4.7.3. RB_tree

```cpp
struct RB_tree
{
    struct node
    {
        int val;
        node* left;
        node* right;
        int color;
        node(){}
        node(int v):val(v),left(nullptr),right(nullptr),color(1){}
        node* parent;
        
        ~node()
        {
            if(left)
                delete left;
            if(right)
                delete right;
        }
    };
    node* root;
    RB_tree()
    {
        root=nullptr;
    }
    ~RB_tree()
    {
        if(root)
            delete root;
    }
    void insert(int val)
    {
        if(!root)
        {
            root=new node(val);
            return;
        }
        node* cur=root;
        while(cur)
        {
            if(cur->val==val)
                return;
            if(cur->val>val)
            {
                if(cur->left)
                    cur=cur->left;
                else
                {
                    cur->left=new node(val);
                    cur->left->parent=cur;
                    insert_fixup(cur->left);
                    return;
                }
            }
            else
            {
                if(cur->right)
                    cur=cur->right;
                else
                {
                    cur->right=new node(val);
                    cur->right->parent=cur;
                    insert_fixup(cur->right);
                    return;
                }
            }
        }
    }
    void insert_fixup(node* cur)
    {
        while(cur->parent->color==1)
        {
            if(cur->parent==cur->parent->parent->left)
            {
                node* uncle=cur->parent->parent->right;
                if(uncle->color==1)
                {
                    cur->parent->color=0;
                    uncle->color=0;
                    cur->parent->parent->color=1;
                    cur=cur->parent->parent;
                }
                else
                {
                    if(cur==cur->parent->right)
                    {
                        cur=cur->parent;
                        left_rotate(cur);
                    }
                    cur->parent->color=0;
                    cur->parent->parent->color=1;
                    right_rotate(cur->parent->parent);
                }
            }
            else
            {
                node* uncle=cur->parent->parent->left;
                if(uncle->color==1)
                {
                    cur->parent->color=0;
                    uncle->color=0;
                    cur->parent->parent->color=1;
                    cur=cur->parent->parent;
                }
                else
                {
                    if(cur==cur->parent->left)
                    {
                        cur=cur->parent;
                        right_rotate(cur);
                    }
                    cur->parent->color=0;
                    cur->parent->parent->color=1;
                    left_rotate(cur->parent->parent);
                }
            }
            if(!cur->parent)
                break;
        }
        root->color=0;
    }
    void left_rotate(node* cur)
    {
        node* right=cur->right;
        cur->right=right->left;
        if(right->left)
            right->left->parent=cur;
        right->parent=cur->parent;
        if(!cur->parent)
            root=right;
        else if(cur==cur->parent->left)
            cur->parent->left=right;
        else
            cur->parent->right=right;
        right->left=cur;
        cur->parent=right;
    }
    void right_rotate(node* cur)
    {
        node* left=cur->left;
        cur->left=left->right;
        if(left->right)
            left->right->parent=cur;
        left->parent=cur->parent;
        if(!cur->parent)
            root=left;
        else if(cur==cur->parent->right)
            cur->parent->right=left;
        else
            cur->parent->left=left;
        left->right=cur;
        cur->parent=left;
    }
    void erase(int val)
    {
        node* cur=root;
        while(cur)
        {
            if(cur->val==val)
                break;
            if(cur->val>val)
                cur=cur->left;
            else
                cur=cur->right;
        }
        if(!cur)
            return;
        node* child;
        if(!cur->left)
            child=cur->right;
        else if(!cur->right)
            child=cur->left;
        else
        {
            node* pre=cur->right;
            while(pre->left)
                pre=pre->left;
            pre->left=cur->left;
            child=cur->right;
        }
        if(cur->color==0)
        {
            if(child)
                child->color=0;
        }
        else
        {
            if(child)
                child->color=1;
            erase_fixup(child);
        }
        if(cur->parent)
        {
            if(cur==cur->parent->left)
                cur->parent->left=child;
            else
                cur->parent->right=child;
        }
        else
            root=child;
        delete cur;
    }
    void erase_fixup(node* cur)
    {
        while(cur)
        {
            if(cur->color==1)
                break;
            if(cur->parent->left==cur)
            {
                node* brother=cur->parent->right;
                if(brother->color==1)
                {
                    brother->color=0;
                    cur->parent->color=1;
                    left_rotate(cur->parent);
                    brother=cur->parent->right;
                }
                if(brother->left->color==0&&brother->right->color==0)
                {
                    brother->color=1;
                    cur=cur->parent;
                }
                else
                {
                    if(brother->right->color==0)
                    {
                        brother->left->color=0;
                        brother->color=1;
                        right_rotate(brother);
                        brother=cur->parent->right;
                    }
                    brother->color=cur->parent->color;
                    cur->parent->color=0;
                    brother->right->color=0;
                    left_rotate(cur->parent);
                    cur=root;
                }
            }
            else
            {
                node* brother=cur->parent->left;
                if(brother->color==1)
                {
                    brother->color=0;
                    cur->parent->color=1;
                    right_rotate(cur->parent);
                    brother=cur->parent->left;
                }
                if(brother->right->color==0&&brother->left->color==0)
                {
                    brother->color=1;
                    cur=cur->parent;
                }
                else
                {
                    if(brother->left->color==0)
                    {
                        brother->right->color=0;
                        brother->color=1;
                        left_rotate(brother);
                        brother=cur->parent->left;
                    }
                    brother->color=cur->parent->color;
                    cur->parent->color=0;
                    brother->left->color=0;
                    right_rotate(cur->parent);
                    cur
                    =root;
                }
            }
        }
        if(cur)
            cur->color=0;
    }
    void print()
    {
        print(root);
    }
    void print(node* cur)
    {
        if(cur)
        {
            print(cur->left);
            cout<<(cur->val)<<" ";
            print(cur->right);
        }
    }
};
```


## 4.8. æ ‘çŠ¶æ•°ç»„

> Description:\
> é€‚åˆå¤„ç†ç±»ä¼¼äºå‰ç¼€å’Œçš„é—®é¢˜

```cpp
struct treeArray
{
    #define lowbit(x) (x&(-x))
    #define N 100000
    int leaf[N];
    int get(int idx)
    {
        int sum=0;
        while(idx>0)
        {
            sum+=leaf[idx];
            idx-=lowbit(idx);
        }
        return sum;
    }
    void update(int idx,int x)
    {
        while(idx<=N)
        {
            leaf[idx]+=x;
            idx+=lowbit(idx);
        }
    }
}
```
